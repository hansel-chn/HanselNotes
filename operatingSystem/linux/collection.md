## linux系统以8进制表示文件权限

如755

第一位7，定义拥有者的权限 第二位5，定义所属组的权限 第三位5，定义其他人的权限

## 动态链接库和静态链接库

> 静态链接库：Windows后缀.lib；Linux后缀.a
> 动态链接困：Windows后缀.ddl；Linux后缀.so

[优点，缺点](https://blog.csdn.net/weixin_39911617/article/details/125495341)


## 操作系统段和页
由于段地址和偏移量的添加方式，单个线性地址最多可以映射到212 = 4096个不同的段:偏移量对。例如，线性地址08124h可以有分段地址06EFh:1234h、0812h:0004h、0000h:8124h等。

这可能会使习惯于唯一寻址方案的程序员感到困惑，但它也可以发挥优势，例如在寻址多个嵌套数据结构时。虽然实模式段总是64 KB长，但实际效果只是没有段可以超过64 KB，而不是每个段都必须是64 KB长。因为在实模式下没有保护或特权限制，即使一个段可以被定义为小于64kb，它仍然完全取决于程序来协调并保持在它们段的边界内，因为任何程序总是可以访问任何内存(因为它可以任意设置段选择器来改变段地址，而完全没有监督)。因此，实模式也可以被想象为每个段的长度都是可变的，在1到65,536字节的范围内，只是CPU没有强制执行。

(为了清晰起见，这里显示了线性地址、分段地址、段和偏移字段的前导零。它们通常被省略。)

实模式的有效20位地址空间将可寻址内存限制在220字节，即1,048,576字节(1mb)。这直接源自于英特尔8086(以及随后的紧密相关的8088)的硬件设计，它恰好有20个地址引脚。(两者都采用40针DIP封装;即使只有20个地址行，地址和数据总线也被多路复用，以适应有限的引脚数内的所有地址和数据线。

每个段从线性(平面)地址空间的起点开始，以16字节的倍数开始，称为段。也就是说，以16字节为间隔。由于所有的段都是64kb长，这就解释了段之间是如何发生重叠的，以及为什么线性内存地址空间中的任何位置都可以被许多段偏移对访问。线段开始在线性地址空间中的实际位置可以用segment×16计算。段值为0Ch(12)将给出线性地址空间中C0h(192)处的线性地址。然后可以将地址偏移量添加到该号码。0Ch:0Fh(12:15)是C0h+0Fh=CFh (192+15=207)， CFh(207)是线性地址。这样的地址转换是由CPU的分段单元进行的。最后一段FFFFh(65535)开始于线性地址FFFF0h(1048560)，在20位地址空间结束前16个字节，因此，可以访问，偏移量高达65,536字节，超过20位8088地址空间结束后最多65,520(65536−16)个字节。在8088上，这些地址访问被包装到地址空间的开头，这样65535:16将访问地址0,65533:1000将访问线性地址空间的地址952。程序员使用这个特性导致了Gate A20的兼容性问题，在后来的CPU代中，线性地址空间扩展超过了20位。

在16位实模式下，允许应用程序使用多个内存段(以便访问比任何一个64k段可用的内存更多的内存)是相当复杂的，但对于除了最小的工具(可以使用更少的内存)之外的所有工具来说都是必要的。问题的根源是没有合适的地址算术指令适合整个内存范围的平面寻址。扁平寻址可以通过应用多个指令实现，但这会导致程序变慢。

内存模型的概念来源于段寄存器的设置。例如，在小型模型CS=DS=SS中，即程序的代码、数据和堆栈都包含在单个64 KB段中。在小内存模型DS=SS中，数据和堆栈都位于同一段中;CS指向一个最大64 KB的不同代码段。

 